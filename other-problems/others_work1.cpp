// 2025-01-30 04:06:14
// #define khnhcodingkarlo      // it'll be used for debugging
#include <bits/stdc++.h>

using namespace std;


// By default, cin and cout are slower than scanf and printf due to synchronization with stdio. 
// fastio() disables synchronization to make cin and cout much faster.
// By default, cin flushes cout before taking input.
// Setting it to nullptr removes this dependency, improving speed.
// cout.tie(nullptr): This removes any tie between cout and cin, further improving efficiency.
//Speed
#define fastio() ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);

//Macros
#define IOtext freopen("input.txt","r",stdin); freopen("output.txt","w",stdout);
#define PI (3.141592653589)
#define M 1000000007
#define pb push_back
#define f first
#define s second
#define foreach(i, j, k, in) for(int i=j;i<k;i+=in)
#define rforeach(i, j, k, in) for(int i=j;i>=k;i-=in)
#define rep(i,j) foreach(i,0,j,1)
#define rrep(i,j) rforeach(i,j,0,1)
#define set_bits(x) __builtin_popcountll(x)
#define zero_bits(x) __builtin_ctzll(x)
#define Num_of_Digits(n) ((int)log10(n) + 1)
#define inint(x) int x; cin>>x;
#define inll(x) long long int x; cin>>x;
#define instr(x) string x; cin>>x;
#define all(x) x.begin(), x.end()
#define out(x) cout << x << endl;
#define py cout<<"YES"<<endl
#define pn cout<<"NO"<<endl
#define pm cout<<"-1"<<endl
#define ps(x,y) fixed<<setprecision(y)<<x

//Typedef
typedef long long ll;
typedef pair<int, int> pi;
typedef pair<ll, ll> pl;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pi> vpi;
typedef vector<pl> vpl;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef map<int,int> mii;
typedef map<ll,ll> mll;
typedef map<char,int> mci;
typedef set<int> st;

// Debug Overloads
#ifdef khnhcodingkarlo
#define debug(x) _print(x); cerr << endl;
#else
#define debug(x)
#endif

void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(double t) {cerr << t;}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.f); cerr << ","; _print(p.s); cerr << "}";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}

// Operator Overloads
template<typename T> // cin >> vector<T>
istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}
template<typename T> // cout << vector<T>
ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << " "; return ostream; }

//Sorting   [These are the lambda functions]
bool sorta(const pair<int,int> &a,const pair<int,int> &b){return (a.second < b.second);}
bool sortd(const pair<int,int> &a,const pair<int,int> &b){return (a.second > b.second);}

//Bits
string decToBinary(int n){string s="";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}
ll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}

//Check
bool isPrime(ll n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}
bool isPowerOfTwo(int n){if(n==0)return false;return (ceil(log2(n)) == floor(log2(n)));}
bool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}

//Constants
vector <ll> primes;
vector <bool> is_prime;

// Mathematical functions
void Sieve(int n){ is_prime.assign(n + 1, true); is_prime[0] = is_prime[1] = false; for(ll i = 2; i * i <= n; i++) if(is_prime[i]) for(ll j = i * i; j <= n; j += i) is_prime[j] = false;}
void get_primes(int n){ for(int i = 2; i <= n; i++)  if(is_prime[i])  primes.push_back(i); }
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll gcd(ll a, ll b){if (b == 0)return a;return gcd(b, a % b);} //__gcd 
ll lcm(ll a, ll b){return (a/gcd(a,b)*b);}
ll moduloMultiplication(ll a,ll b,ll mod){ll res = 0;a %= mod;while (b){if (b & 1)res = (res + a) % mod;b >>= 1;}return res;}
ll powermod(ll x, ll y, ll p){ll res = 1;x = x % p;if (x == 0) return 0;while (y > 0){if (y & 1)res = (res*x) % p;y = y>>1;x = (x*x) % p;}return res;}
//To find modulo inverse, call powermod(A,M-2,M)


struct Node {
	vl val; // may change
	Node() { // Identity element
        val = {0,0,0,0,0,0,0,0};  // may change
	}
	Node(ll p1) {  // Actual Node
        vl temp(8,0);
        temp[p1]=1;
		val = temp; // may change
	}
	void merge(Node &l, Node &r) { // Merge two child nodes
        vl temp(8,0);
        rep(i,8)
        {
            rep(j,8)
            {
                temp[i^j] += moduloMultiplication(l.val[i],r.val[j],M);
                temp[i^j] %= M;
            }
        }
        val = temp;  // may change
        rep(i,8)
        {
            val[i] += mod_add(l.val[i],r.val[i],M);
            val[i] %= M;
        }
	}
};

struct Update {
	vl val; // may change
	Update(ll p1) { // Actual Update
        vl temp(8,0);
        temp[p1]=1;
		val = temp; // may change
	}
	void apply(Node &a) { // apply update to given node
		a.val = val; // may change
	}
};

struct SegTree {
	vector<Node> tree;
	vector<ll> arr; // type may change
	int n;
	int s;
	SegTree(int a_len, vector<ll> &a) { // change if type updated
		arr = a;
		n = a_len;
		s = 1;
		while(s < 2 * n){
			s = s << 1;
		}
		tree.resize(s); fill(all(tree), Node());
		build(0, n - 1, 1);
	}
	void build(int start, int end, int index)  // Never change this
	{
		if (start == end)	{
			tree[index] = Node(arr[start]);
			return;
		}
		int mid = (start + end) / 2;
		build(start, mid, 2 * index);
		build(mid + 1, end, 2 * index + 1);
		tree[index].merge(tree[2 * index], tree[2 * index + 1]);
	}
	void update(int start, int end, int index, int query_index, Update &u)  // Never Change this
	{
		if (start == end) {
			u.apply(tree[index]);
			return;
		}
		int mid = (start + end) / 2;
		if (mid >= query_index)
			update(start, mid, 2 * index, query_index, u);
		else
			update(mid + 1, end, 2 * index + 1, query_index, u);
		tree[index].merge(tree[2 * index], tree[2 * index + 1]);
	}
	Node query(int start, int end, int index, int left, int right) { // Never change this
		if (start > right || end < left)
			return Node();
		if (start >= left && end <= right)
			return tree[index];
		int mid = (start + end) / 2;
		Node l, r, ans;
		l = query(start, mid, 2 * index, left, right);
		r = query(mid + 1, end, 2 * index + 1, left, right);
		ans.merge(l, r);
		return ans;
	}
	void make_update(int index, ll val) {  // pass in as many parameters as required
		Update new_update = Update(val);    // may change
		update(0, n - 1, 1, index, new_update);
	}
	Node make_query(int left, int right) {
		return query(0, n - 1, 1, left, right);
	}
};

ll MEX(const vector<ll> &nums)
{
    unordered_set<ll> numSet(nums.begin(), nums.end()); // Store all elements in a hash set
    ll mex = 0;
    while (numSet.count(mex))
    {
        mex++; // Increment until we find a missing number
    }
    return mex;
}

int32_t main()
{
    fastio()
    //Rating? Neh. In love with experience.
    //Code Karlo, Coz KHNH :)

    vl grundy(200005, 0);
    grundy[0] = 0;
    for(ll i=1;i<=200000;i++)
    {
        ll num = i;
        vl nums;
        while(num)
        {
            ll d = num%10;
            num/=10;
            if(d>0)
                nums.pb(i-d);
        }
        for(auto &it:nums) it=grundy[it];
        grundy[i] = MEX(nums);
    }

    auto solve = [&] () {   // lambda function capturing the variables of main by reference!
        ll n;
        cin>>n;
        vl a(n);
        cin>>a;
        ll q;
        cin>>q;
        rep(i,n) a[i]=grundy[a[i]];
        SegTree tree = SegTree(n,a);
        while(q--)
        {
            ll operationType;
            cin>>operationType;
            if(operationType==2)
            {
                ll idx, x;
                cin>>idx>>x;
                idx--;
                a[idx]=grundy[x];
                tree.make_update(idx,a[idx]);
            }
            else
            {
                ll l,r;
                cin>>l>>r;
                l--,r--;
                ll range = r-l+1;
                ll ans = (powermod(2,range,M) - tree.make_query(l,r).val[0] - 1);
                if(ans<0) ans+=M;
                out(ans);
            }
            for(auto it:tree.tree)
            {
                debug(it.val);
            }
        }
    };

    int t;
    t=1;
    while(t--)
    {
        solve();
    }
    return 0;
}